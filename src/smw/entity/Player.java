package smw.entity;

import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.ImageObserver;

import smw.Game;
import smw.gfx.Palette.ColorScheme;
import smw.gfx.Sprite;
import smw.level.Level;
import smw.level.Tile;
import smw.ui.PlayerControlBase;

public class Player extends Rectangle{
	/**
	 * Autogenerated!
	 */
	private static final long serialVersionUID = -4197702383138211374L;
	private static final long RESPAWN_WAIT_MS = 2000;
	Sprite  sprite;
	public PlayerPhysics physics;
	Score score;
	final public int playerIndex;
	public boolean crushed = false;
	long respawnTime;
	//This is used to track how far a player really can move
	public int dx, dy;
	
	public Player(PlayerControlBase playerControl, int playerIndex){	
		physics = new PlayerPhysics(playerControl);
		sprite  = new Sprite();
		score   = new Score();
		this.playerIndex = playerIndex;
	}
	
	void setBounds(int newX, int newY){
	  //TODO might be a faster way (width/height never change)
		setBounds(newX, newY, Sprite.IMAGE_WIDTH, Sprite.IMAGE_HEIGHT);			
	}
	
	public Image getImage(){
		return sprite.getImage();
	}
	
	public void init(int newX, int newY, String image){
		setBounds(newX, newY);
		
		//TODO this is obviously not staying in
		int i = (int)(4*Math.random());
		ColorScheme color = ColorScheme.YELLOW;
		if(i == 0){
		  color = ColorScheme.RED;
		}
		else if(i == 1){
      color = ColorScheme.GREEN;
    }
		else if(i == 2){
      color = ColorScheme.BLUE;
    }
		
		sprite.init(image, color);
	}
	
	public void updateValuesToPrepareForMove(){  
   if(crushed){
      //TODO this is messy and should be a method called at the beginning
      if(respawnTime < System.currentTimeMillis()){
        crushed = false;
        setBounds(300, 100);
        sprite.setJumping();
      }
    }
   
   physics.update();
   dx = (int)physics.getVelocityX();
   dy = (int)physics.getVelocityY();
   sprite.update(dx, dy, physics.isJumping, physics.isSkidding);  
	}
		
	public void move(){			
	  setBounds(x + dx, y + dy);
	}
		
	public void crush(){
		crushed = true;
		//TODO mk didn't like this but if you want to play with it, make gameFrame static and this works 
		//Game.gameFrame.bump();
		respawnTime = System.currentTimeMillis() + RESPAWN_WAIT_MS;
		sprite.crush();
	}
	
	public void poll(){
		physics.poll();
	}
	
	public void draw(Graphics2D graphics, ImageObserver observer){
	  graphics.drawImage(sprite.getImage(), x, y, observer);
	}
	
	public int getScore(){
		return score.getScore();
	}
}
